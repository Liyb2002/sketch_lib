#!/usr/bin/env python3
"""
cluster_grouping.py

Cluster re-grouping using:
  - full 3D point cloud from trellis_outputs/<name>.ply
  - 20-cluster PartField labels from partfield_clusters/<name>_k20.npy
  - per-view initial 3D overlays in final_overlays/view_{i}_overlap3d[_relaxed].ply

For each view i:
  - Interpret unique colors in view_{i}_overlap3d*.ply as labels for that sketch
  - Map these overlay points to nearest full-cloud points
  - For each PartField cluster, see which label it mostly belongs to
  - Clusters belonging to the same label share the same color
  - Clusters not selected by any label are black
  - Save + visualize a .ply file showing the re-grouped clusters for that view

Additionally:
  - At the start, visualize raw PartField clusters, each in one random color.
  - Save a JSON mapping (per view, per label) of which clusters belong to which label.
"""

from pathlib import Path
from typing import Dict, Tuple
import json

import numpy as np
import open3d as o3d


# ---------------------------------------------------------------------
# CONFIG
# ---------------------------------------------------------------------

ROOT = Path(__file__).resolve().parent

# If None, will auto-pick the first .ply in trellis_outputs
OBJECT_NAME = None  # e.g. "0_trellis_gaussian"

TRELLIS_DIR = ROOT / "trellis_outputs"      # full point cloud(s)
CLUSTER_DIR = ROOT / "partfield_clusters"   # <name>_k20.npy generated by run_partfield.py
OVERLAY_DIR = ROOT / "final_overlays"       # view_{i}_overlap3d.ply / view_{i}_overlap3d_relaxed.ply

OUT_DIR = ROOT / "regrouped_clusters_ply"   # outputs

NUM_VIEWS = 6  # view_0 ... view_5

# A cluster is assigned to a label only if that label covers at least this fraction
DOMINANCE_THRESH = 0.5

# Overlay points whose color is (almost) black are treated as "no label"
BLACK_THRESH = 1e-3


# ---------------------------------------------------------------------
# HELPERS
# ---------------------------------------------------------------------

def load_object_name() -> Tuple[str, Path]:
    """Pick object name and point-cloud path."""
    if OBJECT_NAME is not None:
        pc_path = TRELLIS_DIR / f"{OBJECT_NAME}.ply"
        if not pc_path.is_file():
            raise RuntimeError(f"Point cloud not found: {pc_path}")
        return OBJECT_NAME, pc_path

    ply_files = sorted(TRELLIS_DIR.glob("*.ply"))
    if not ply_files:
        raise RuntimeError(f"No .ply files found in {TRELLIS_DIR}")
    pc_path = ply_files[0]
    name = pc_path.stem
    print(f"[INFO] OBJECT_NAME not set, auto-using: {name}")
    return name, pc_path


def build_full_kdtree(pcd_full: o3d.geometry.PointCloud) -> o3d.geometry.KDTreeFlann:
    """Build KDTree for nearest-neighbor mapping from overlay points to full cloud."""
    return o3d.geometry.KDTreeFlann(pcd_full)


def get_overlay_labels_from_colors(colors: np.ndarray) -> np.ndarray:
    """
    Given overlay point colors (N,3), map each point to a discrete label ID
    based on its color.

    - Each unique color (except near-black) becomes a label.
    - Returns label_ids: shape (N,), labels in {0..L-1} or -1 for "ignored".
    """
    N = colors.shape[0]

    # Filter out "black" as no-label (we assume black is background)
    is_black = np.linalg.norm(colors, axis=1) < BLACK_THRESH

    # Quantize colors to reduce float noise
    quantized = (colors * 255.0 + 0.5).astype(np.int32)

    # Unique colors among non-black points
    valid_idx = np.where(~is_black)[0]
    if valid_idx.size == 0:
        # No labeled points
        return np.full(N, -1, dtype=np.int32)

    uniq_colors, inverse = np.unique(quantized[valid_idx], axis=0, return_inverse=True)

    # Map each non-black point to [0..num_labels-1]
    label_ids = np.full(N, -1, dtype=np.int32)
    label_ids[valid_idx] = inverse

    print(f"[INFO] Found {uniq_colors.shape[0]} overlay labels in this view.")
    return label_ids


def assign_clusters_from_overlay(
    pcd_full: o3d.geometry.PointCloud,
    cluster_ids: np.ndarray,
    overlay_pcd: o3d.geometry.PointCloud,
    dominance_thresh: float = 0.5,
) -> Tuple[np.ndarray, Dict[int, np.ndarray], np.ndarray]:
    """
    Use overlay3d points to re-group PartField clusters:

    - overlay_pcd has per-point colors encoding labels.
    - We map each overlay point to nearest full-cloud point.
    - For each cluster, tally how many hits per label.
    - A cluster is assigned to the label with the largest count,
      if that label dominates enough.

    Returns:
      cluster_to_label: shape (num_clusters,), each in {0..L-1} or -1 for "unassigned".
      label_to_color:   dict {label_id -> RGB float in [0,1]}
      overlay_labels:   array of per-overlay-point label ids (for optional debugging)
    """
    points_full = np.asarray(pcd_full.points)
    colors_overlay = np.asarray(overlay_pcd.colors)
    points_overlay = np.asarray(overlay_pcd.points)

    num_clusters = int(cluster_ids.max()) + 1

    # 1) Extract discrete overlay labels from overlay colors
    overlay_labels = get_overlay_labels_from_colors(colors_overlay)
    used_mask = overlay_labels >= 0
    if not np.any(used_mask):
        print("[WARN] No labeled overlay points (only black?)")
        return np.full(num_clusters, -1, dtype=np.int32), {}, overlay_labels

    points_overlay_used = points_overlay[used_mask]
    labels_used = overlay_labels[used_mask]

    # 2) Map overlay points → full cloud via nearest neighbor
    kdtree = build_full_kdtree(pcd_full)
    full_indices = []

    print(f"[INFO] Mapping {points_overlay_used.shape[0]} overlay points to full cloud…")
    for p in points_overlay_used:
        _, idx, _ = kdtree.search_knn_vector_3d(p, 1)
        full_indices.append(idx[0])
    full_indices = np.array(full_indices, dtype=np.int64)

    # 3) For each of these matched full points, know (cluster, overlay_label)
    matched_clusters = cluster_ids[full_indices].astype(np.int64)
    labels_used = labels_used.astype(np.int64)

    max_label = int(labels_used.max())
    num_labels = max_label + 1

    # Safety: filter out any invalid indices
    valid_idx = (
        (matched_clusters >= 0) & (matched_clusters < num_clusters) &
        (labels_used >= 0) & (labels_used < num_labels)
    )
    matched_clusters = matched_clusters[valid_idx]
    labels_used = labels_used[valid_idx]

    # cluster x label count
    counts = np.zeros((num_clusters, num_labels), dtype=np.int32)
    np.add.at(counts, (matched_clusters, labels_used), 1)

    # 4) Decide cluster -> label
    cluster_to_label = np.full(num_clusters, -1, dtype=np.int32)
    for k in range(num_clusters):
        row = counts[k]
        total = row.sum()
        if total == 0:
            continue
        best_L = int(row.argmax())
        if row[best_L] / total >= dominance_thresh:
            cluster_to_label[k] = best_L

    # 5) Build a stable color per label based on overlay colors
    label_to_color: Dict[int, np.ndarray] = {}
    for L in range(num_labels):
        pts_L = colors_overlay[overlay_labels == L]
        if pts_L.size == 0:
            continue
        # mean color of that label in overlay
        label_to_color[L] = pts_L.mean(axis=0)

    print(f"[INFO] Assigned {np.sum(cluster_to_label >= 0)} / {num_clusters} clusters.")
    return cluster_to_label, label_to_color, overlay_labels


def color_full_cloud(
    points_full: np.ndarray,
    cluster_ids: np.ndarray,
    cluster_to_label: np.ndarray,
    label_to_color: Dict[int, np.ndarray],
) -> np.ndarray:
    """
    Build per-point colors for the full cloud:

      - clusters assigned to label L get label_to_color[L]
      - clusters with label -1 are black
    """
    N = points_full.shape[0]
    colors = np.zeros((N, 3), dtype=np.float32)  # default black

    for i in range(N):
        k = int(cluster_ids[i])
        L = int(cluster_to_label[k])
        if L >= 0 and L in label_to_color:
            colors[i] = label_to_color[L]
        # else stays black

    return colors


def color_by_raw_clusters(points_full: np.ndarray, cluster_ids: np.ndarray) -> o3d.geometry.PointCloud:
    """
    Debug helper: color each PartField cluster with its own random color,
    so you can see the raw 20 clusters before regrouping.
    """
    num_clusters = int(cluster_ids.max()) + 1
    rng = np.random.RandomState(0)
    cluster_colors = rng.rand(num_clusters, 3).astype(np.float32)

    colors = cluster_colors[cluster_ids]  # (N,3)

    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(points_full)
    pcd.colors = o3d.utility.Vector3dVector(colors)
    return pcd


# ---------------------------------------------------------------------
# MAIN
# ---------------------------------------------------------------------

def main():
    OUT_DIR.mkdir(parents=True, exist_ok=True)

    # 1) choose object + full PC
    name, pc_path = load_object_name()

    # 2) load full point cloud
    pcd_full = o3d.io.read_point_cloud(str(pc_path))
    points_full = np.asarray(pcd_full.points)
    N_full = points_full.shape[0]
    print(f"[INFO] Loaded full cloud: {N_full} points from {pc_path.name}")

    # 3) load 20-cluster labels (force to int)
    cluster_path = CLUSTER_DIR / f"{name}_k20.npy"
    if not cluster_path.is_file():
        raise RuntimeError(f"Missing cluster labels: {cluster_path}")
    cluster_ids = np.load(cluster_path).reshape(-1).astype(np.int64)
    if cluster_ids.shape[0] != N_full:
        raise RuntimeError(
            f"Cluster label count {cluster_ids.shape[0]} != point count {N_full}"
        )
    num_clusters = int(cluster_ids.max()) + 1
    print(f"[INFO] Loaded k20 labels ({num_clusters} clusters).")

    # 3.5) DEBUG: visualize raw clusters (each in one color)
    raw_cluster_pcd = color_by_raw_clusters(points_full, cluster_ids)
    raw_out_path = OUT_DIR / f"{name}_raw_clusters.ply"
    o3d.io.write_point_cloud(str(raw_out_path), raw_cluster_pcd)
    print(f"[INFO] Saved raw clusters colored by cluster ID to {raw_out_path}")
    # print("[INFO] Visualizing raw clusters (close window to continue)...")
    # vis0 = o3d.visualization.Visualizer()
    # vis0.create_window(window_name=f"Raw PartField clusters – {name}")
    # vis0.add_geometry(raw_cluster_pcd)
    # opt0 = vis0.get_render_option()
    # opt0.point_size = 3.0
    # opt0.light_on = True
    # vis0.run()
    # vis0.destroy_window()

    # -----------------------------------------------------------------
    # 4) per-view regrouping + JSON mapping
    # -----------------------------------------------------------------
    mapping_json = {
        "object_name": name,
        "num_clusters": int(num_clusters),
        "views": {}
    }

    for view_idx in range(NUM_VIEWS):
        # Prefer relaxed overlap if present
        relaxed_path = OVERLAY_DIR / f"view_{view_idx}_overlap3d_relaxed.ply"
        base_path = OVERLAY_DIR / f"view_{view_idx}_overlap3d.ply"

        if relaxed_path.is_file():
            overlay_path = relaxed_path
        elif base_path.is_file():
            overlay_path = base_path
        else:
            print(f"[WARN] Missing overlay for view {view_idx}: "
                  f"{relaxed_path.name} / {base_path.name}, skipping.")
            continue

        overlay_pcd = o3d.io.read_point_cloud(str(overlay_path))
        if not overlay_pcd.has_points():
            print(f"[WARN] Overlay has no points for view {view_idx}, skipping.")
            continue
        if not overlay_pcd.has_colors():
            print(f"[WARN] Overlay has no colors for view {view_idx}, skipping.")
            continue

        print(f"\n[INFO] Processing view {view_idx} from {overlay_path.name}")

        cluster_to_label, label_to_color, overlay_labels = assign_clusters_from_overlay(
            pcd_full=pcd_full,
            cluster_ids=cluster_ids,
            overlay_pcd=overlay_pcd,
            dominance_thresh=DOMINANCE_THRESH,
        )

        # Build full-cloud colors for this view
        colors_full = color_full_cloud(
            points_full=points_full,
            cluster_ids=cluster_ids,
            cluster_to_label=cluster_to_label,
            label_to_color=label_to_color,
        )

        # Create colored full PC for this view
        pcd_view = o3d.geometry.PointCloud()
        pcd_view.points = o3d.utility.Vector3dVector(points_full)
        pcd_view.colors = o3d.utility.Vector3dVector(colors_full)

        out_path = OUT_DIR / f"{name}_view{view_idx}_regrouped.ply"
        o3d.io.write_point_cloud(str(out_path), pcd_view)
        print(f"[INFO] Saved regrouped 3D segments for view {view_idx} to {out_path}")

        # ---- Build JSON mapping for this view ----
        view_entry = {"labels": []}

        # all labels that were actually assigned to at least one cluster
        used_labels = np.unique(cluster_to_label[cluster_to_label >= 0])
        for L in used_labels:
            L = int(L)
            clusters_for_L = np.where(cluster_to_label == L)[0].tolist()
            color = label_to_color.get(L, np.array([0.0, 0.0, 0.0], dtype=float))
            view_entry["labels"].append({
                "label_id": L,
                "name": f"label_{L}",              # you can later map this to "backrest", "seat", etc.
                "color_rgb": [float(c) for c in color],
                "clusters": clusters_for_L,        # list of PartField cluster IDs
            })

        mapping_json["views"][str(view_idx)] = view_entry

        # Visualize results for this view
        # print("[INFO] Visualizing regrouped clusters (close window to continue)...")
        # vis = o3d.visualization.Visualizer()
        # vis.create_window(window_name=f"Cluster regrouping – {name} – view {view_idx}")
        # vis.add_geometry(pcd_view)
        # opt = vis.get_render_option()
        # opt.point_size = 3.0
        # opt.light_on = True
        # vis.run()
        # vis.destroy_window()

    # -----------------------------------------------------------------
    # 5) Save JSON mapping
    # -----------------------------------------------------------------
    json_path = OUT_DIR / f"{name}_cluster_label_mapping.json"
    with open(json_path, "w") as f:
        json.dump(mapping_json, f, indent=2)
    print(f"\n[INFO] Saved cluster-to-label mapping JSON to {json_path}")

    print("\n[DONE] Saved & visualized regrouped clusters for all available views.")


if __name__ == "__main__":
    main()
